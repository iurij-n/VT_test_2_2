## Задание 2.2

#### Стэк:
- python
- asyncio, aiohttp
- PyQt5

Desktop-приложение, реализующие следующие функции:
 - форма ввода URL-адресов
 - форма ввода списка xpath для поиска данных на странице
 - подключение по TCP и отправка HTTP GET-запроса по каждому адресу
 - получение HTML-контента и парсинг
 - вывод результатов по каждому запросу

Приложение имеет графическией итерфейс. В верхнее окно списком вводятся URL. Во второе окно вводится список xPath. Поиск информации осуществляется по всем путям на каждой странице.
Для каждого URL в списке создается отдельная задача, после этого все задачи запускаются на выполнение одновременно. Результат парсинга выводится в нижнем окне интерфейса и сохраняются в файле `result.txt`.

Данные для проверки работы программы:
- Список URL

https://www.chay.info/catalog/chay/angliyskiy_sadovnik.html

https://www.chay.info/catalog/kofe/turetskiy_myed.html

https://www.chay.info/catalog/kofe/martsipan.html

https://www.chay.info/catalog/kofe/lesnoy_orekh.html

https://www.chay.info/catalog/kofe/belgiyskie_vafli.html

https://www.chay.info/catalog/kofe/chokolato_latte_makkiato_.html


- Список xPath

//*[@id="product_name"]

//*[@id="product_price_current"]

#### Инструкция по запуску

- Клонировать репозиторий
```
git clone https://github.com/iurij-n/VT_test_2_2.git
```
- Создать виртуальное окружение
```
python -m venv venv
```
- Активировать виртуальное окружение
для Windows
```
source venv/Scripts/activate
```
для Linux
```
source venv/bin/activate
```
- Установить зависимости
```
pip install -r requirements.txt
```
- Запустить приложение
```
python pars_gui.py
```
=================================================


## Задание 1.1:
Есть 2 таблицы Table_A, Table_B

Структура таблиц
Table_A:

Id (int), Name (string)

Table_B:
Id (int), Name (string), Id_A (int)

Id_A - ссылка на запись в таблице Table_A

==================================

**Вопрос 1:**
*Сколько записей вернет запрос следующий запрос?
select * from Table_A inner join Table_B*

**Ответ:**
Так как  в запросе нет условия объединения таблиц, будет возвращено так называемое прямое перемножение множеств - сначала будет выведена первая запись из "левой" Table_A в паре с каждой записью "правой" Table_B, затем вторая запись из Table_A в паре с каждой записью Table_B и т.д. Ответ на вопрос - число записей в Table_A  умноженное на число записей в Table_B.


**Вопрос 2:**
*Сколько записей вернет следующий запрос?
select * from Table_A a inner join Table_B b on a.ID=b.Id_A*

**Ответ:**
В запросе указано условие фильтрации - значение поля Id_A таблицы Table_B должно быть равно значению поля ID таблицы Table_A. Таким образом, на этот запрос, будут выведены те записи из таблицы Table_B, для которых выполнится условие из запроса. Число выведенных записей может отличаться от общего числа записей в Table_B, т.к. в условии задачи нет требования обязательного заполнения поля Id_A.

**Вопрос 3:**
*Чем отличаются следующие запросы?
select * from Table_A a inner join Table_B b on a.ID=b.Id_A
select * from Table_A a left join Table_B b on a.ID=b.Id_A*

**Ответ:**
Результат первого запроса описан в ответе на вопрос 2. В ответ на второй запрос будут выведены вообще все записи "левой" Table_A, как те, для которых выполняется условие объединения, так и те, для которых не выполняется (вместо недостающих значений будет выведено NULL).